<!DOCTYPE html>
<html lang="en">

    <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><title>fetipop &ndash; kqx</title>
<meta name="description" content="">

<meta name="viewport" content="width=device-width, initial-scale=1">
<meta charset="UTF-8"/>



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha512-Kc323vGBEqzTmouAECnVceyQqyqdsSiqLQISBL29aUW4U/M7pSPA/gEUZQqv1cwx4OnYxTxve5UMg5GT6L4JJg==" crossorigin="anonymous" referrerpolicy="no-referrer" />


<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.9.4/css/academicons.min.css" integrity="sha512-IW0nhlW5MgNydsXJO40En2EoCkTTjZhI3yuODrZIc8cQ4h1XcF53PsqDHa09NqnkXuIe0Oiyyj171BqZFwISBw==" crossorigin="anonymous" referrerpolicy="no-referrer" />


<link rel="stylesheet" href="http://localhost:1313/css/palettes/base16-dark.css">
<link rel="stylesheet" href="http://localhost:1313/css/risotto.css">
<link rel="stylesheet" href="http://localhost:1313/css/custom.css">












<meta property="og:title" content="fetipop &ndash; kqx" />
<meta property="og:url" content="http://localhost:1313/post/fetipop/" />

  
    <meta property="og:description" content=""/> 
  

<meta property="og:locale" content="en-us" />
<meta property="og:image" content="" /></head>

    <body>
        <div class="page">

            <header class="page__header"><nav class="page__nav main-nav">
    <ul>
      <li class="nomarker"><h1 class="page__logo"><a href="http://localhost:1313/" class="page__logo-inner">kqx</a></h1></li>
    
    
    <li class="main-nav__item"><a class="nav-main-item" href="http://localhost:1313/about/" title="">About</a></li>
    
    <li class="main-nav__item"><a class="nav-main-item active" href="http://localhost:1313/post/" title="Posts">Posts</a></li>
    
    </ul>
</nav>

</header>
            
            <section class="page__body">
    <header class="content__header">
        <h1>fetipop</h1>
    </header>
    <div class="content__body">
        <h2 id="zero_pfn">zero_pfn</h2>
<p>When mmap gets called the physical address doesn&rsquo;t get immediately mapped, instead a <code>VMA</code> is created: VMAs are structures that describe userspace virtual mappings. <br>
When a fetch on a non-mapped address happens a pagefault occurs and gets handled gracefully by the kernel which starts walking the VMAs. If the faulted address has a VMA then the physical page gets allocated and mapped and the process continues its execution.</p>
<p>What&rsquo;s the point of this?
Memory efficiency. There&rsquo;s no need to consume memory until we have data to store. <br>
If the first access is a write then the page gets allocated, but if it&rsquo;s a read then we don&rsquo;t yet need to store data, thus no need to consume memory. However an address must still be mapped in order not to make the MMU fail the pagewalk. Zero_pfn will be used as a temp page for read-only accesses until a write is performed, which will result in the actual memory allocation.</p>
<h2 id="phys-kaslr-leak">Phys kASLR leak</h2>
<p>In dirty pagetable scenarios, attackers usually tend to bruteforce the physical base of the kernel which can be easily done with page-level UAFs, but results harder with partial corruptions of the PMDs. <br>
By mapping the zero_pfn we can immediately leak an address that belongs to the kernel memory section.</p>
<h2 id="zero_pfn-to-idt">zero_pfn to IDT</h2>
<p>In every version of the linux kernel the IDT is mapped right after the zero_pfn, which means that with a partial corruption of a PTE we can get rw access on the IDT, which will lead to LPE.</p>
<blockquote>
<p>Usecases</p>
</blockquote>
<p>There are various scenarios where we can get a partial corruption of a PTE, such as:</p>
<ul>
<li><code>struct file</code> UAF: as explained in the original dirty pagetable paper we can make a <code>struct file</code> overlap with a PMD and modify PTEs by <code>dup</code>ing the associated fd which will increase the refcount. By allocating shared memory, thus an unmoveable page, with enough feng shui we can get a page-level UAF. Feng shui could lead to unreliability and need of userns to spray the correct objects. Through zero_pfn we can skip the whole feng shui and still get LPE. Take as example this <a href="https://ptr-yudai.hatenablog.com/entry/2023/12/08/093606">blog</a>: the use of the dma_heap driver, phys kASLR leak through <code>0x9c000</code> physical address and page-level UAF could have been avoided.</li>
<li>heap BOFs: through a partial overwrite of a PTE, zero_pfn can be corrupted into IDT with just 2 bytes: 3 nibble for flags and 1 of physical address. Given that phys kASLR is THP-aligned there&rsquo;s no need to bruteforce that last nibble as it will be predictable.</li>
</ul>
<p><strong>This technique is useful for partial and/or restricted dirty pagetable scenarios without requiring any feng shui thus without losing any reliability and without ever needing any physical leaks.</strong></p>
<h2 id="iop-interrupt-oriented-programming">IOP (Interrupt Oriented Programming)</h2>
<p>IDT (Interrupt Descriptor Table) is a page that contains information about how the kernel should handle a fault or an interrupt. <br>
The information contained in an interrupt descriptor are <a href="https://wiki.osdev.org/Interrupt_Descriptor_Table">these</a>. <br>
One of the fields contains the address of the handler, where we can leak kASLR from and, by modifying it, get RIP hijacking.</p>
<p>Even though we hijacked the control flow, getting code execution could be difficult for these reasons:</p>
<ul>
<li>RSP get modified when an interrupt occurs in ring 3, thus we don&rsquo;t have an immediate ROPchain</li>
<li>if kPTI is enabled, we can only jump to gadgets in the kPTI trampoline, making it hard to pivot the stack to a controlled region</li>
</ul>
<p>An advantage is that we have full control of the other registers, given that only RIP, RSP, CS and SS gets modified by interrupts.</p>
<p>Even though there aren&rsquo;t useful ROP gagets in the kPTI trampoline, we do have IOP gadgets: <br>
We define an IOP gadget as any piece of code that, instead of ending with a ret instruction like in a ROP, it ends with a fault or interrupt, and given that we have full control of the handlers, we can chain such gadgets and get a full chain. <br>
This way we don&rsquo;t need to control any data region to store a ROPchain, thus not needing further leaks such as the heap.</p>
<p>Most of the handlers are meant for handling faults, which doesn&rsquo;t normally happen so corrupting them won&rsquo;t crash anything. The only handlers that get trivially triggered are pagefaults and scheduling-related interrupts.</p>
<p>Through IOP we can build common chains that can lead to arbitrary code execution, an example could be:</p>
<ul>
<li>div by 0 from userland to enter the chain -&gt; offset&rsquo;d <code>entry_SYSCALL_64</code> (kPTI pagetable swap) -&gt; pagefault (on RSP gs-based fetch, given that user gs will be invalid) that throws -&gt;</li>
<li>double fault (RSP gets overwritten with CR3 so the pagefault handler call fails) -&gt; <code>entry_SYSRETQ_unsafe_stack</code>  (swapgs; sysret) -&gt;</li>
<li>general protection fault (sysret requires a canonical return address in RCX, and given that we have full control on registers we can make it fault) -&gt; <code>set_memory_x</code> (pass IDT as address to make it executable) -&gt;</li>
<li>invalid opcode (because of a check in <code>cpa_flush</code> a <code>BUG_ON</code> will be called) -&gt; IDT to execute shellcode</li>
</ul>
<p>This is more or less a universal IOPchain, given that the functions taken in account are consistent across all the recent kernel versions.</p>
<p>Special thanks to @prosti for finding the <code>set_memory_x</code> path &lt;3</p>
<h2 id="bypassing-smap">bypassing SMAP</h2>
<p>In the <code>EFLAGS</code> register there&rsquo;s a bit called <code>AC</code> (Alignment Check) which, if set on, doesn&rsquo;t allow unaligned memory movs; in kernelspace it although has a different meaning: it is used to temporarily disabling SMAP in order to copy data from/to userland. <br>
Fun fact: because of its duality, it can be set from userland. Ok but, how can we exploit this? <br>
Clearly linux is not this much broken to let you fuck up SMAP like this, (see IA32_FMASK MSR: <code>https://www.felixcloutier.com/x86/syscall</code>). In every ring 3 -&gt; ring 0 context switch routine, <code>AC</code>, in a way or another, gets set off. For interrupts, every handler begins with the <code>clac</code> instruction. <br>
This leads to a SMAP bypass in IOP scenarios: by not executing the real handler, the <code>clac</code> instruction will never be run thus <code>AC</code> will remain set and SMAP disabled.</p>
<p>The idea is: enable <code>AC</code>, set up a fake stack in userland and redirect an interrupt to a <code>mov rsp, X; ret</code> gadget: ez ROP. <br>
If kPTI is off then it&rsquo;s an easy win, but if it is enabled then we&rsquo;ll probably still need IOP to swap pagetables. If you manage to find a ROP gadget in the kPTI trampoline to swap pagetables let us know :).</p>
<pre tabindex="0"><code>pushf
or qword ptr [rsp], 0x40000
popf
</code></pre><p>Thanks to <strong>@Erge</strong> for finding such path &lt;3</p>
<h2 id="lore-moment">Lore moment</h2>
<p>fetipop should have been my challenge for <a href="https://github.com/TheRomanXpl0it/TRX-CTF-2025">TRXCTF 2025</a> which I decided not to release in order not to leak the technique and give a shot to kctf. <br>
<a href="/kpwn-blog/attachments/fetipop.zip">Try it out ;)</a></p>
<p><strong>what does the first &ldquo;p&rdquo; stand for in fetipop?</strong> <br>
fetipop is a meme name we came up for the chall after writing it. <br>
Basically trying to name the technique (IOP) we were (as a joke) considering various options like &ldquo;Fault OP&rdquo;, &ldquo;Exception OP&rdquo;, &ldquo;Trap OP&rdquo; and, of course, &ldquo;Interrupt OP&rdquo;. We then merged them all together in <code>fetiop</code>, the last &ldquo;p&rdquo; was casually mentioned by <strong>@Erge</strong> because of an inside joke of ours, we only know what its real meaning is and we won&rsquo;t elaborate any further.</p>

    </div>
    <footer class="content__footer"></footer>

            </section>
            
            
                <section class="page__aside">
                    <div>
    <p>novel technique I found in the linux kernel useful to exploit restricted dirty pagetable scenarios in a completely reliable and leakless way, through a new kind of &#34;Oriented Programming&#34;.</p>
    
        <p>
            By leave, 
            2025-07-30
        </p>
    

    
        <hr>
        On this page:
        <section class="post__toc">
            <nav id="TableOfContents">
  <ol>
    <li><a href="#zero_pfn">zero_pfn</a></li>
    <li><a href="#phys-kaslr-leak">Phys kASLR leak</a></li>
    <li><a href="#zero_pfn-to-idt">zero_pfn to IDT</a></li>
    <li><a href="#iop-interrupt-oriented-programming">IOP (Interrupt Oriented Programming)</a></li>
    <li><a href="#bypassing-smap">bypassing SMAP</a></li>
    <li><a href="#lore-moment">Lore moment</a></li>
  </ol>
</nav>
        </section>
    


                    </div>
                </section>
            

            <section class="page__about">
                <div>
    


                </div>
            </section>


            <footer class="page__footer"><p>
    
    
    
    
    
    
      
    
      
    
    
    
      
      
          
            
            
                <br/><span class="active">$ echo $LANG<br/><b></b></span><br/>

            
          
      
    
</p>
<br /><br />
<p class="advertisement" style="margin-left: 5px; font-size: 14px;">Made with love by <strong>@leave</strong> & <strong>@prosti</strong>.</p>
</footer>

        </div>
    </body>

</html>
